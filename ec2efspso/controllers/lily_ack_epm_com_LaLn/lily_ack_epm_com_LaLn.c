/*
 * File:          
 * Date: 17 March 2017     
 * Description: Lily controller using ruleset as on the real robots
 * Author: Bahar Haghighat 
 * Modifications: 
   By Hala Khodr on 19 July 2017 
   Elimination of the inconsistency in the labels update. 
 */
 
 
#include <webots/supervisor.h> 
#include <webots/emitter.h>
#include <webots/receiver.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <time.h>
#include <math.h>

/*
 * Ruleset header files as generated by Matlab script export_rules
 */
#include <rules_singleton_chain5_LaLn.h>
//#include <rules_linchpin_cross_LaLn.h>
//#include <rules_RGS_cross_LaLn.h>
//#include <rules_linchpin_chain_LaLn.h>
//#include <rules_RGS_chain_LaLn_original.h>

/*
 * You may need to add include files like <webots/distance_sensor.h> or
 * <webots/differential_wheels.h>, etc.
 */
#include <webots/robot.h>
#include <webots/connector.h> 

/*
 * You may want to add defines macro here.
 */
#define FSM_DEFAULT 0
#define FSM_CHECK_NEIGHBOR 1
#define FSM_EPM_RECEIVE_NEIGHBOR 2

#define TRUE 1
#define FALSE 0

#define ENABLED 1
#define DISABLED 0
#define EPM_OFF_TIME 256 /* 32ms each step, 8s off time */

#define NB_CONNECTORS 4

#define EPM_COMMUNICATION_CHANNEL 1
#define RADIO_COMMUNICATION_CHANNEL 11

#define COMM_PERIOD 15
#define TRANSMISSION_TIME_OUT 5
#define NB_HISTORY 4

#define PROB_SIZE 3 
/*
 * Global variables
 */
static WbNodeRef robot_node;
static WbFieldRef robot_field_data;
static const char *data;
char robot_name[256];
int my_ID;
char temp_char[256];
int new_link = FALSE;
int EPM_neighborhood[NB_CONNECTORS] = {0, 0, 0, 0};
int neighbor_talking[NB_CONNECTORS] = {0, 0, 0, 0}; // binary flag, if on each epm someone is talking to me
int epms_talking[NB_CONNECTORS] = {0, 0, 0, 0}; // emps on which a message has been received are listed from bottom to top, for random selection
time_t t;
int myRandomNumber;
int random_number; 
int FSM_state = 0;
int updated_by_neighbor=0; 
WbDeviceTag connectors[NB_CONNECTORS];
int connected[NB_CONNECTORS];
int locked[NB_CONNECTORS];
int EPM_activation_state[NB_CONNECTORS] = {ENABLED, ENABLED, ENABLED, ENABLED};
int EPM_off_counter[NB_CONNECTORS] = {0, 0, 0, 0};
int connections_n;
static double time_step;

int internalState = 0xFF;
int internalStateEPM_la[NB_CONNECTORS] = {0, 0, 0, 0};
int internalStateEPM_ln[NB_CONNECTORS] = {0, 0, 0, 0};
int neighborState_la[NB_CONNECTORS] = {0xFF, 0xFF, 0xFF, 0xFF};
int neighborState_ln[NB_CONNECTORS] = {0xFF, 0xFF, 0xFF, 0xFF};
int neighborState_ln_abs,internalStateEPM_ln_abs;
int neighborRandomNumber[NB_CONNECTORS] = {0, 0, 0, 0};
int neighborID[NB_CONNECTORS] = {0, 0, 0, 0};
int neighbor_epm[NB_CONNECTORS] = {0, 0, 0, 0};
int newNeighborHistory[NB_HISTORY] = {0xFF, 0xFF, 0xFF, 0xFF};

static int epm_check_neighbour = 0;

int epm_trans_active = FALSE;
int am_initiator = FALSE;
int am_responder = FALSE;
int communication_counter = 0;
int epm_trans_timer = 2;
static int engaged_epm = 0;


int prob[PROB_SIZE];
/*
 * Debug variables
 */
int rule_type = 0;
long combined_state = 0xFFFF;
int ID = 0;

/*
 * Function declarations
 */
 
static void reset(void);
void update_state(void);
void apply_rule(void);
void reenable_EPMs(void);
void emit_on_enabled_EPMs(void);
int emit_on_next_EPM(void);
int emit_on_all_EPMs(void);
void reset_EPM_receiver_buffers(void);
bool respond_self_state(int epm_out);
void read_buffer(int engaged_epm, double currentTime);
void check_for_new_prob(void);
// robot supervisor initialization
void robot_label_init();

/*
 * This is the main program.
 * The arguments of the main function can be specified by the
 * "controllerArgs" field of the Robot node
 */
int peer_connector; 
int main(int argc, char **argv)
{
  int now = 0;
  char device_name[50];
  WbDeviceTag communication;
  double currentTime = 0.0;
  printf("%lf *** Started Lily controller ***\n",currentTime);
	
  /* necessary to initialize webots stuff, initializes communication between controller and Webots */
  wb_robot_init();
  time_step = wb_robot_get_basic_time_step();   
  reset();
 

  
  
      /* main loop */
  do {
    check_for_new_prob();
    rule_type = 0;
    /* check if EPMs should be enabled after off time */
    reenable_EPMs();
    switch(FSM_state) 
    {
      case FSM_DEFAULT: // be idle, listen, decide what to do next
      {
        //printf("FSM_STATE is %d for Lily %d time %f\n", FSM_state, my_ID, currentTime);
        FSM_state = FSM_DEFAULT;
        /*sprintf(device_name,"EPM%d",engaged_epm+1); // EPMi receiver 
        peer_connector=wb_connector_get_presence( wb_robot_get_device(device_name) );
        printf("Lily %d epm %d peer connection: %d \n",my_ID,engaged_epm+1,peer_connector);*/
          if ((rand() < RAND_MAX/10))
          {
            FSM_state = FSM_CHECK_NEIGHBOR; // when it's time to say hello do it, incomming messages won't be lost
          }
          else
          {
            int total_neighbor_talking = 0;
            int i,j = 0;
            epms_talking[0] = 0xFF;
            epms_talking[1] = 0xFF;
            epms_talking[2] = 0xFF;
            epms_talking[3] = 0xFF;
            // find out who has been talking to me
            for (i = 0; i < NB_CONNECTORS; i++)
            {
              neighbor_talking[i] = 0;
              sprintf(device_name,"EPM%d_Rx",i+1); /* EPMi receiver */
              communication = wb_robot_get_device(device_name); 
              if (wb_receiver_get_queue_length(communication) > 0)
              {
                //printf("yyyyyyyyyyy  Lily %d, initiator state %d, internal state %d, contacted on EPM %d\n", my_ID, am_initiator, internalStateEPM_la[engaged_epm], i+1); 
                neighbor_talking[i] = 1;
                total_neighbor_talking += 1;
                epms_talking[j] = i;
                j += 1;
              }
            }
            
            if (total_neighbor_talking) // if neighbors being initiators, choose one randomly to reply to 
            {
              //printf("Lily %d total neighbor talking %d\n", my_ID, total_neighbor_talking);
              int rnd_index = round((rand()/(double)RAND_MAX)*(total_neighbor_talking-1));
              //printf("Lily number %d rnd_index = %d epms_talking %d %d %d %d\n", my_ID, rnd_index, epms_talking[0], epms_talking[1], epms_talking[2], epms_talking[3]);
              engaged_epm = epms_talking[rnd_index];
              //printf("**********  Lily number %d on EPM number %d\n", my_ID, engaged_epm+1);
              epm_trans_active = TRUE;   
              am_responder = TRUE;
              am_initiator =  FALSE;
              //bool fff= respond_self_state(engaged_epm);
              sprintf(device_name,"EPM%d_Rx",engaged_epm+1); // EPMi receiver
              communication = wb_robot_get_device(device_name); 
              const char *buffer = wb_receiver_get_data(communication);
              int is_Initiator = 0;
              int ID = 0;
              int State_la = 0;
              int State_ln = 0;
              int Random = 0;
              int epm=0;
              
              sscanf(buffer, "%d %d %d %d %d %d", &is_Initiator, &ID, &State_la, &State_ln, &epm, &Random);
              
              
              /// update my neighbour 
  
              char data_struct[256];
              int init=0;
              int update =1;
              int index=0;
              for(i=0;i<PROB_SIZE;i++)
                 index+=sprintf(&data_struct[index],"%d ",prob[i]);
             
              char data_struct2[256];
              sprintf(data_struct2, "%x %d %d %d %d %d %d %d %d", State_la,State_ln,update,init, my_ID, internalStateEPM_la[engaged_epm], internalStateEPM_ln[engaged_epm], engaged_epm, myRandomNumber);   
              char robot_def[256];
              sprintf(robot_def, "LILY%d",ID);
              WbNodeRef robot_node=wb_supervisor_node_get_from_def(robot_def);
              strcat(data_struct,data_struct2);
              //printf("data is %s sending update: my neighbor is %d \n",data_struct,ID);
              WbFieldRef robot_field_data=wb_supervisor_node_get_field(robot_node,"la_ln");
              wb_supervisor_field_set_sf_string(robot_field_data,data_struct);
              //printf("********** Time: %f Lily number %d responding on EPM number %d sending succeed? %d \n", currentTime, my_ID, engaged_epm+1,1) ;//,fff);
              FSM_state = FSM_EPM_RECEIVE_NEIGHBOR; 
              
            }
          }
       
        /* generate a new random number for probabilistic rules */
        myRandomNumber = rand();
        break;
      }
        
      case FSM_CHECK_NEIGHBOR: // act as initiator, send state to one selected neighbor
      {
         if(emit_on_next_EPM())
        {
          epm_trans_timer = TRANSMISSION_TIME_OUT;
          engaged_epm = epm_check_neighbour;
         // printf("xxxxxxxxxx  Time: %f Lily %d emitted on EPM %d internal state %d\n", currentTime, my_ID, engaged_epm+1, internalStateEPM_la[engaged_epm]); 
          communication_counter = 0;
          am_initiator = TRUE;
          epm_trans_active = TRUE;
          reset_EPM_receiver_buffers();          
          FSM_state = FSM_EPM_RECEIVE_NEIGHBOR;
        }
        break;
      }
      
      
      case FSM_EPM_RECEIVE_NEIGHBOR: // see if you have received a response from the neighbor you talked to, update state
      {
    //  printf("FSM_STATE is %d for Lily %d time %f am_initiator %d\n", FSM_state, my_ID, currentTime,am_initiator);

          // check if I received a request to update from my neighbor    
          int la, ln, update=0;
          robot_node = wb_supervisor_node_get_self();
          robot_field_data=wb_supervisor_node_get_field(robot_node,"la_ln");
          data = wb_supervisor_field_get_sf_string(robot_field_data);
          int offset;
          int i;
         
          
          for(i=0;i<PROB_SIZE;i++)
          {
            sscanf(data," %d%n",&prob[i],&offset);
            data+=offset;
          }
          
          
          sscanf(data,"%x %d %d",&la,&ln,&update);
          
     
          
          
          // check if I received a message from my neighbor 
          sprintf(device_name,"EPM%d_Rx",engaged_epm+1); // EPMi receiver
          communication = wb_robot_get_device(device_name); 
          
        if (wb_receiver_get_queue_length(communication) > 0||update)
        { 
        
          //printf("Time: %f I am Lily %d  recieving on epm %d update %d \n", currentTime, my_ID,engaged_epm+1, update); 
          new_link = 0;
          if (neighborState_la[engaged_epm] == 0xFF) new_link = 1;
          int is_Initiator = 0;
          int ID = 0;
          int State_la = 0;
          int State_ln = 0;
          int Random = 0;
          int epm=0;
          
          if(update)
          {
          sscanf(data, "%x %d %d %d %d %d %d %d %d", &la,&ln,&update,&is_Initiator, &ID, &State_la, &State_ln, &epm, &Random);
          updated_by_neighbor=1;
         
          }
         
          else 
          {
          
          const char *buffer = wb_receiver_get_data(communication);          
          sscanf(buffer, "%d %d %d %d %d %d", &is_Initiator, &ID, &State_la, &State_ln, &epm, &Random);
          //printf("Time: %f message received by Lily %d initiator %d on EPM %d state %d from Lily %d %d %d %d %d\n", currentTime, my_ID, am_initiator, engaged_epm, internalStateEPM_la[engaged_epm], ID, is_Initiator, State_la, State_ln, Random);
          //if (am_initiator && is_Initiator) printf("**********************  Time: %f message received by Lily %d initiator %d on EPM %d state %d from Lily %d %d %d %d %d\n", currentTime, my_ID, am_initiator, engaged_epm, internalStateEPM_la[engaged_epm], ID, is_Initiator, State_la, State_ln, Random);
          //if (!am_initiator && !is_Initiator) printf("______________________  Time: %f message received by Lily %d initiator %d on EPM %d state %d from Lily %d %d %d %d %d\n", currentTime, my_ID, am_initiator, engaged_epm, internalStateEPM_la[engaged_epm], ID, is_Initiator, State_la, State_ln, Random);
          }
          if ((am_initiator && !is_Initiator) || (!am_initiator && is_Initiator))
          //if(1)
          {
            epm_trans_timer = 0;
            neighborID[engaged_epm] = ID;
            neighborState_la[engaged_epm] = State_la;
            neighborState_ln[engaged_epm] = State_ln;
            neighborRandomNumber[engaged_epm] = Random;
            neighbor_epm[engaged_epm]=epm;
           // printf("Time: %f correct comm Lilies %d and %d initiator state %d and %d internal state %d and %d\n", currentTime, my_ID, ID, am_initiator, is_Initiator, internalStateEPM_la[engaged_epm], neighborState_la[engaged_epm]); 
            update_state();
          }
        }
        if (am_initiator && epm_trans_timer)
        { //printf("aaaaaaaaa Time: %f I am Lily %d epm %d \n", currentTime, my_ID,engaged_epm+1); 
          epm_trans_timer = epm_trans_timer - 1;
          FSM_state = FSM_EPM_RECEIVE_NEIGHBOR;
        }
        else 
        { // printf("eeeeeeee Time: %f I am Lily %d  \n", currentTime, my_ID); 
          reset_EPM_receiver_buffers();
          FSM_state = FSM_DEFAULT;
          epm_trans_active = FALSE;
          am_initiator = 0;
          am_responder = 0;
        }
        break;
      }
   
     
      default:
      printf("NO FSM_STATE CASE WAS FOUND\n");
      break;
    }

    /* 
     * Perform a simulation step of 64 milliseconds
     * and leave the loop when the simulation is over
     */
    now++;
    //robot_label_init();
    currentTime += time_step/1000.0;
  } while (wb_robot_step(time_step) != -1);
  
  /* Enter here exit cleanup code */
  /* Necessary to cleanup webots stuff */
  wb_robot_cleanup();
  
  return 0;
}

/*
 * You should put some helper functions here
 */
 


void update_state(void)
{
  if (am_initiator)
  {
    random_number = myRandomNumber;
  }
  else
  {
    random_number = neighborRandomNumber[engaged_epm];
  }
        
  apply_rule();

  epm_trans_active = FALSE;
  am_initiator = 0;
  am_responder = 0;
}

void apply_rule(void)
{
  // generate combined state for efficient lookup : in a 16 bits integer, the smallest state occupies the first 8 bits, and the biggest the 8 last
  bool swap = FALSE;
  int initial_state_int = (internalStateEPM_la[engaged_epm] << 8) | internalStateEPM_ln[engaged_epm];
  int initial_state_neigh = (neighborState_la[engaged_epm] << 8) | neighborState_ln[engaged_epm];
  int initial_state1 = 0;
  int initial_state2 = 0;
  int final_state1 ;
  int final_state2 ;
  int ln_abs1; // start counting from 0 from ln_abs
  int ln_abs2; // start counting from 0 from ln_abs
  
 /* if (!updated_by_neighbor)
  {
    /// update my neighbour 
  
  char data_struct[256];
  int init=0;
  int update =1;
  sprintf(data_struct, "%x %d %d %d %d %d %d %d %d", neighborState_la[engaged_epm],neighborState_ln[engaged_epm],update,init, my_ID, internalStateEPM_la[engaged_epm], internalStateEPM_ln[engaged_epm], engaged_epm, myRandomNumber);   
  char robot_def[256];
  sprintf(robot_def, "LILY%d",neighborID[engaged_epm] );
  printf("sending update: my neighbor is %d \n",neighborID[engaged_epm]);
  WbNodeRef robot_node=wb_supervisor_node_get_from_def(robot_def);
  WbFieldRef robot_field_data=wb_supervisor_node_get_field(robot_node,"la_ln");
  wb_supervisor_field_set_sf_string(robot_field_data,data_struct);
  }
  */
  updated_by_neighbor=0;
  if (initial_state_int == initial_state_neigh && !am_initiator) 
  { // if neigbour and local states are equal, communication am_initiator comes first
    initial_state1 = initial_state_neigh;
    initial_state2 = initial_state_int;
    swap = TRUE;
      
  }
  else 
  { //else put local state first
    initial_state1 = initial_state_int;
    initial_state2 = initial_state_neigh;
    
  }	
    //find a rule
    final_state1 = 0;
    final_state2 = 0;
    ln_abs1 = engaged_epm;  //neighbor_epm[engaged_epm]; // start counting from 0 from ln_abs
    ln_abs2 = engaged_epm; // start counting from 0 from ln_abs	
    			
  //probabilistic rules : get the random number
  //int random_number = 0xFF;

  //int rule_type = 0;
				
  //LOOK_FOR_RULE()
  //printf("Lily %d state %d on EPM %d neighbor with Lily %d on epm %d state %d found rule of type %d new_link %d random_number is %d combined_state: %x %x  \n", my_ID, internalStateEPM_la[engaged_epm], engaged_epm+1, neighborID[engaged_epm],neighbor_epm[engaged_epm]+1, neighborState_la[engaged_epm], rule_type, new_link,random_number,initial_state1,initial_state2);
  LOOK_FOR_RULE_CHAIN_EXT()
  //LOOK_FOR_RULE_CROSS_EXT()				
  //printf("Lily %d state %d on EPM %d neighbor with Lily %d state %d found rule of type %d new_link %d random_number is %d \n", my_ID, internalStateEPM_la[engaged_epm], engaged_epm+1, neighborID[engaged_epm], neighborState_la[engaged_epm], rule_type, new_link,random_number);
  
  //update states
  
  if (rule_type != 0) 
  {
    if (swap) 
    {// apply increasing states, starting from the epm that has just connected      
      internalStateEPM_la[0] = final_state2;
      internalStateEPM_la[1] = final_state2;
      internalStateEPM_la[2] = final_state2;
      internalStateEPM_la[3] = final_state2;

      int i;
      for (i = 0; i < NB_CONNECTORS; i++)
        {
          if (final_state2 == 0)
          {
            internalStateEPM_ln[(ln_abs2+i)%4] = 0;
          }
          else
          {
            internalStateEPM_ln[(ln_abs2+i)%4] = i;
          }
          
        }
            
    }
    else 
    {// apply increasing states, starting from the epm that has just connected      
      internalStateEPM_la[0] = final_state1;
      internalStateEPM_la[1] = final_state1;
      internalStateEPM_la[2] = final_state1;
      internalStateEPM_la[3] = final_state1;

      int i;
      for (i = 0; i < NB_CONNECTORS; i++)
        {
          if (final_state1 == 0)
          {
            internalStateEPM_ln[(ln_abs1+i)%4] = 0;
          }
          else
          {
            internalStateEPM_ln[(ln_abs1+i)%4] = i;
          
          }
            
      
       }
   }

  }   
  
   ///update my label 
  char data_struct[256];
  int index=0;
  int i;
  for(i=0;i<PROB_SIZE;i++)
     index+=sprintf(&data_struct[index],"%d ",prob[i]);
 
  char data_struct2[256];
  // printf("resetting update \n");
  sprintf(data_struct2, "%x %d %d", internalStateEPM_la[engaged_epm], internalStateEPM_ln[engaged_epm],0);  
  strcat(data_struct,data_struct2);
  wb_robot_set_custom_data(data_struct);
  
  // stay latched, or unlatch
  switch(rule_type) 
  {
    case 1: //link rule, stay latched
      break;
    case 2: // unlink rule
      wb_connector_unlock(connectors[engaged_epm]);
      EPM_activation_state[engaged_epm] = DISABLED;
      EPM_off_counter[engaged_epm] = 0;
      neighborState_la[engaged_epm] = 0xFF;
      neighborState_ln[engaged_epm] = 0xFF;
      EPM_neighborhood[engaged_epm] = 0;
      break;
    case 3: //update rule, stay latched
      break;
    default:  // unlatch when no rule is found for a new link, else stay latched
      if (new_link == 1)
      //if (EPM_neighborhood[engaged_epm])
      {
        wb_connector_unlock(connectors[engaged_epm]);
        EPM_activation_state[engaged_epm] = DISABLED;
        EPM_off_counter[engaged_epm] = 0;
        neighborState_la[engaged_epm] = 0xFF;
        neighborState_ln[engaged_epm] = 0xFF;
        EPM_neighborhood[engaged_epm] = 0;
        
      }
      
      //no unlink or update rule was applied, we don't want a message sent through the radio
      //else state->state_changed = 0;
      break;
   }
   
}

void reenable_EPMs(void)
{
  int i;
  for (i = 0; i < NB_CONNECTORS; i++)
  {
    if (EPM_activation_state[i] == DISABLED)
    {
      EPM_off_counter[i] += 1;
      if ((EPM_off_counter[i] > (rand()/(double)RAND_MAX)*EPM_OFF_TIME) && wb_connector_get_presence(connectors[i]) == 0)
      {
        wb_connector_lock(connectors[i]);
        EPM_activation_state[i] = ENABLED;
      }
    }
  }
}

/* sends state on next EPM*/
int emit_on_next_EPM(void)
{
    char device_name[50];
    WbDeviceTag communication;
    int init = 1; // initiator Lily
      if(++epm_check_neighbour > 3) epm_check_neighbour = 0;
      if (EPM_activation_state[epm_check_neighbour] == ENABLED)
      {
        sprintf(device_name,"EPM%d_Tx",epm_check_neighbour+1); /* EPMi emitter */
        communication = wb_robot_get_device(device_name); 
        char message[256];
        sprintf(message, "%d %d %d %d %d %d", init, my_ID, internalStateEPM_la[epm_check_neighbour], internalStateEPM_ln[epm_check_neighbour],epm_check_neighbour, myRandomNumber);
        wb_emitter_send(communication, message, strlen(message) + 1);
        //printf("my initiation: 0, id , la , ln, rnd : %s \n", message);
        return 1;
      }
  return 0;
}

/* sends state on all EPMs*/
int emit_on_all_EPMs(void)
{
    char device_name[50];
    WbDeviceTag communication;
    int i, init = 1; // initiator Lily
    for (i = 0; i < NB_CONNECTORS; i++)
    {
      epm_check_neighbour = i;
      if (EPM_activation_state[epm_check_neighbour] == ENABLED)
      {
        sprintf(device_name,"EPM%d_Tx",epm_check_neighbour+1); /* EPMi emitter */
        communication = wb_robot_get_device(device_name); 
        char message[256];
        sprintf(message, "%d %d %d %d %d", init, my_ID, internalStateEPM_la[epm_check_neighbour], internalStateEPM_ln[epm_check_neighbour], myRandomNumber);
        wb_emitter_send(communication, message, strlen(message) + 1);
        
        return 1;
      }
    }
  return 0;
}

/* sends state on all EPMs*/
bool respond_self_state(int epm_out)
{
    char device_name[50];
    WbDeviceTag communication;
    int init = 0; // responder Lily
    sprintf(device_name,"EPM%d_Tx",epm_out+1); /* EPMi emitter */
    communication = wb_robot_get_device(device_name); 
    char message[256];
    sprintf(message, "%d %d %d %d %d %d", init, my_ID, internalStateEPM_la[epm_out], internalStateEPM_ln[epm_out],epm_out, myRandomNumber);
    //printf("my response: 0, id , la , ln, rnd : %s \n", message);
    bool succeed= wb_emitter_send(communication, message, strlen(message) + 1); 
   
    return succeed;
}

void reset_EPM_receiver_buffers(void)
{
  char device_name[50];
  int i;
  WbDeviceTag communication;
  for (i = 0; i < NB_CONNECTORS; i++)
    {
      sprintf(device_name,"EPM%d_Rx",i+1); /* EPMi receiver */
      communication = wb_robot_get_device(device_name); 
      while (wb_receiver_get_queue_length(communication) != 0)
      { //printf("Lily %d resetting \n",my_ID);
        wb_receiver_next_packet(communication);
       
      }
    }
}

void robot_label_init(){
  int i=0;
  int la, ln,update;
  
  robot_node = wb_supervisor_node_get_self();
  robot_field_data=wb_supervisor_node_get_field(robot_node,"la_ln");
  data = wb_supervisor_field_get_sf_string(robot_field_data);
  //printf("%s\n",data);

  sscanf(data,"%x %d %d",&la,&ln,&update);

  /*for(i=0;i<NB_CONNECTORS;i++){
    if(neighborState_la[i]!=255){
      if(neighborState_la[i]>maxTmp){
        maxInd = i;
      }
    }
  }*/
  for(i=0;i<NB_CONNECTORS;i++){
   if (la == 0)
     {
       internalStateEPM_ln[i] = 0;
     }
    else
     {
       internalStateEPM_ln[(ln+i)%NB_CONNECTORS] = i;
      }
    
    internalStateEPM_la[i] = la;
      
    }
  
  //internalStateEPM_ln[engaged_epm] = ln;
 // printf("ID %d: engaged_epm %d \n",my_ID,engaged_epm);

}

static void reset() 
{
  int i;
  char device_name[50];
  char field_name[50];
  WbDeviceTag communication;
  
  for (i = 0; i < NB_CONNECTORS; i++)
  {
    sprintf(device_name,"EPM%d",i+1);
    connectors[i] = wb_robot_get_device(device_name);

    wb_connector_enable_presence(connectors[i], time_step);
    connected[i] = 0;
    locked[i] = 1; 
  }
  connections_n=0;
  
  for (i = 0; i < NB_CONNECTORS; i++)
  {
    sprintf(device_name,"EPM%d_Tx",i+1); /* EPMi emitter */
    communication = wb_robot_get_device(device_name); 
    wb_emitter_set_channel(communication, EPM_COMMUNICATION_CHANNEL);
    
    sprintf(device_name,"EPM%d_Rx",i+1); /* EPMi receiver */
    communication = wb_robot_get_device(device_name); 
    wb_receiver_enable(communication, time_step);
  }
  
  robot_node = wb_supervisor_node_get_self();
  sprintf(field_name, "%s", "name");
  sprintf(robot_name, "%s", wb_supervisor_field_get_sf_string(wb_supervisor_node_get_field(robot_node, field_name)));
  sscanf(robot_name, "%s %d", temp_char, &my_ID); 
  //printf("I am Lily number %d\n", my_ID);
  
  /* Intializes random number generator */
  srand((unsigned) time(&t) + my_ID);
  //printf("RAND_MAX is %d\n", RAND_MAX);
}

void check_for_new_prob() 
{
       
      
     
      WbNodeRef robot_node;
      robot_node = wb_supervisor_node_get_self();
      static WbFieldRef robot_field_data_update_prob;
      robot_field_data_update_prob=wb_supervisor_node_get_field(robot_node,"la_ln"); //update the probabilities      
      static const char *data_prob_check;
      data_prob_check=wb_supervisor_field_get_sf_string(robot_field_data_update_prob);
      int i;
      int offset;
      //printf("Probabilities are ");
      for(i=0;i<PROB_SIZE;i++)
     {
      sscanf(data_prob_check," %d%n",&prob[i],&offset);
      data_prob_check+=offset;
      //printf("%d  ",prob[i]);
     }
     // printf("\n");

}

